<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#ddd">
<meta name="generator" content="Hexo 6.0.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#ddd">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-X7rrn44l1+AUO65h1LGALBbOc5C5bOstSYsNlv9MhT8=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/@fancyapps/fancybox/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.imssyang.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"right","width":300,"display":"hide","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"rgba(255, 255, 255, 0.1)","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Disqus","order":-1},"gitalk":{"text":"Github","order":-2}}},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>
<meta name="description" content="各种排序算法的复杂度是不同的，对于小数据集，简单算法通常执行的更好，数据集越大，复杂算法的优势才会越明显。">
<meta property="og:type" content="article">
<meta property="og:title" content="排序">
<meta property="og:url" content="https://blog.imssyang.com/Algorithm/Sort.html">
<meta property="og:site_name" content="Just Do It">
<meta property="og:description" content="各种排序算法的复杂度是不同的，对于小数据集，简单算法通常执行的更好，数据集越大，复杂算法的优势才会越明显。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-04T09:16:00.000Z">
<meta property="article:modified_time" content="2021-08-09T01:16:30.000Z">
<meta property="article:author" content="Ssyang">
<meta property="article:tag" content="Sort">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.imssyang.com/Algorithm/Sort.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://blog.imssyang.com/Algorithm/Sort.html","path":"Algorithm/Sort.html","title":"排序"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>排序 | Just Do It</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Just Do It</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">by Ssyang</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">比较类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">插入类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">树排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.4.</span> <span class="nav-text">图书馆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">选择类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%88%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">圈排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">链排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">交换类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">奇偶排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%87%E6%91%86%E5%BC%8F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">摇摆式排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8F%E5%84%92%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">侏儒排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A2%B3%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">梳排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">归并类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quad%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">Quad排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">分治类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">快速排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">混合类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">内省排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E6%AF%94%E8%BE%83%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">非比较类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">基数排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">3.</span> <span class="nav-text">C</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-STL"><span class="nav-number">4.</span> <span class="nav-text">C++ (STL)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ssyang"
      src="/images/imssyang/windmill.png">
  <p class="site-author-name" itemprop="name">Ssyang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/imssyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;imssyang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imssyang@gmail.com" title="E-Mail → mailto:imssyang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/lib/@creativecommons/vocabulary/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.dabeaz.com/" title="https:&#x2F;&#x2F;www.dabeaz.com" rel="noopener" target="_blank">David Beazley</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://coldattic.info/" title="http:&#x2F;&#x2F;coldattic.info" rel="noopener" target="_blank">A Foo Walks into a Bar...</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.brendangregg.com/" title="https:&#x2F;&#x2F;www.brendangregg.com" rel="noopener" target="_blank">Brendan Gregg's Homepage</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.wowza.com/blog" title="https:&#x2F;&#x2F;www.wowza.com&#x2F;blog" rel="noopener" target="_blank">WOWZA Media Systems</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://preshing.com/" title="https:&#x2F;&#x2F;preshing.com" rel="noopener" target="_blank">Preshing on Programming</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.yinwang.org/" title="https:&#x2F;&#x2F;www.yinwang.org" rel="noopener" target="_blank">当然我在扯淡</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.jianchihu.net/" title="https:&#x2F;&#x2F;blog.jianchihu.net" rel="noopener" target="_blank">剑痴乎</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://betterexplained.com/" title="https:&#x2F;&#x2F;betterexplained.com" rel="noopener" target="_blank">Better Explained</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.mathsisfun.com/" title="https:&#x2F;&#x2F;www.mathsisfun.com" rel="noopener" target="_blank">Math is Fun</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://notes.shichao.io/" title="https:&#x2F;&#x2F;notes.shichao.io" rel="noopener" target="_blank">Shichao's Notes</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.shuxuele.com/" title="https:&#x2F;&#x2F;www.shuxuele.com" rel="noopener" target="_blank">数学乐</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://thispointer.com/" title="https:&#x2F;&#x2F;thispointer.com" rel="noopener" target="_blank">thisPointer</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://refactoring.guru/" title="https:&#x2F;&#x2F;refactoring.guru" rel="noopener" target="_blank">Refactoring.Guru</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.imssyang.com/Algorithm/Sort.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/imssyang/windmill.png">
      <meta itemprop="name" content="Ssyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Just Do It">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序
            <div class="post-categories">
              [
                  <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                    <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                  </span>
              ]
            </div>
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 5/4/2021 17:16:00" itemprop="dateCreated datePublished" datetime="2021-05-04T17:16:00+08:00">5/4/2021</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 8/9/2021 09:16:30" itemprop="dateModified" datetime="2021-08-09T09:16:30+08:00">8/9/2021</time>
    </span>

  
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>34k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>31 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>各种排序算法的复杂度是不同的，对于小数据集，简单算法通常执行的更好，数据集越大，复杂算法的优势才会越明显。</p>
<span id="more"></span>

<p><strong>关键属性</strong>：比较次数与移动次数。</p>
<ul>
<li>如果比较的是整数与字符，代价不大。如果是数字数组或者字符串，代价显著提高；</li>
<li>如果移动的是结构，代价也会非常突出。</li>
</ul>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>最好情况（通常数据已排序）</li>
<li>最坏情况（数据按相反顺序排列）</li>
<li>平均情况（数据顺序是随机的）</li>
</ul>
<p><strong>空间复杂度</strong>：</p>
<ul>
<li>运行过程占用的临时空间的大小。如果输入数据中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是<strong>原址的（in place）</strong>。</li>
</ul>
<p><strong>稳定性</strong>：当待排序的数据集中含有多个相同的元素，经过排序后，如果这些相同元素的相对位置保持不变，则称这种排序算法是稳定的。</p>
<h1 id="比较类"><a href="#比较类" class="headerlink" title="比较类"></a>比较类</h1><h2 id="插入类"><a href="#插入类" class="headerlink" title="插入类"></a>插入类</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将无序数据依次插入有序集中。每次都从有序集的尾部开始比较并后移有序集中的元素，直至找到合适位置后插入数据。</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">best</th>
<th align="left">average</th>
<th align="left">worst</th>
<th align="left">memory</th>
<th align="left">stable</th>
<th align="left">method</th>
<th align="left">notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">insertsort</td>
<td align="left">n</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">yes</td>
<td align="left">插入</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="insertsort"><ul class="nav-tabs"><li class="tab active"><a href="#insertsort-1">pseudo</a></li><li class="tab"><a href="#insertsort-2">c</a></li><li class="tab"><a href="#insertsort-3">c++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="insertsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">insertsort(a[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 从第2个元素开始</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> to n</span><br><span class="line">        <span class="comment"># 暂存待排序元素</span></span><br><span class="line">        tmp = a[<span class="type">i</span>]</span><br><span class="line">        <span class="comment"># 向前遍历，依次将大于待排序元素的值后移一位</span></span><br><span class="line">        <span class="keyword">for</span> j = i to <span class="number">2</span> and tmp &lt; a[<span class="type">j</span>-<span class="number">1</span>]</span><br><span class="line">            a[<span class="type">j</span>] = a[<span class="type">j</span>-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 将待排序元素放置在正确位置</span></span><br><span class="line">        a[<span class="type">j</span>] = tmp</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="insertsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertsort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; a[j<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="insertsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; A[j<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">        &#125;           </span><br><span class="line">        A[j] = tmp; </span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>1959年<code>Donald L. Shell</code>设计而得名，此时时间复杂度为$N^2$。<br>1973年<code>Donald Ervin Knuth</code>改良增量值为$3^k-1 \over 2$，对应具体值为<code>1,4,13,40,121</code>，时间复杂度为$N^3 \over 2$。<br>1982年<code>Sedgewick</code>改良增量值为$4^k+3·2^{k-1}+1$，对应具体值为<code>1,8,23,77,281</code>，时间复杂度为$N^4 \over 3$。<br>希尔排序可看成对<a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><strong>插入排序</strong></a>的一种改进。通过增量将数据分割成多个子数据，子数据的数量等于增量大小，子数据的相邻元素间隔也为增量大小，使用简单算法（多为插入排序）对各子数据进行排序，使得数据愈加有序。当增量减小到1时，等同于使用基础算法排序少量乱序的数据。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ShellSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n^{4 \over 3}$</td>
<td align="left">$n^{3 \over 2}$</td>
<td align="left">1</td>
<td align="left">no</td>
<td align="left">插入</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="shellsort"><ul class="nav-tabs"><li class="tab active"><a href="#shellsort-1">Pseudo</a></li><li class="tab"><a href="#shellsort-2">C</a></li><li class="tab"><a href="#shellsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="shellsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ShellSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 计算增值序列</span></span><br><span class="line">    m: n/<span class="number">3</span></span><br><span class="line">    G[<span class="type">m</span>]: &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">40</span>,<span class="number">121</span>,...&#125; (<span class="built_in">h</span>=<span class="number">3</span><span class="built_in">h</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 从最大的增量值开始排序子数组</span></span><br><span class="line">    <span class="keyword">for</span> i = m to <span class="number">1</span></span><br><span class="line">        <span class="built_in">h</span> = G[<span class="type">i</span>]</span><br><span class="line">        <span class="comment"># 依次排序当前增量对应的各子数组（此时j对应子数组的第2个元素）</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="built_in">h</span> to <span class="number">2</span>*<span class="built_in">h</span><span class="literal">-1</span></span><br><span class="line">            <span class="comment"># 排序当前子数组（常用插入排序，因此从第2个元素开始）</span></span><br><span class="line">            <span class="keyword">for</span> k = j to n</span><br><span class="line">                <span class="comment"># 暂存待排序元素</span></span><br><span class="line">                tmp = A[<span class="type">k</span>]</span><br><span class="line">                <span class="comment"># 向前遍历，依次将大于待排序元素的值后移一位</span></span><br><span class="line">                l = k</span><br><span class="line">                <span class="keyword">for</span> l<span class="literal">-h</span> &gt;= <span class="number">1</span> and tmp &lt; A[<span class="type">l</span>-<span class="type">h</span>]</span><br><span class="line">                    A[<span class="type">l</span>] = A[<span class="type">l</span>-<span class="type">h</span>]</span><br><span class="line">                    l = l - <span class="built_in">h</span></span><br><span class="line">                <span class="comment"># 将待排序元素放置在正确位置</span></span><br><span class="line">                A[<span class="type">l</span>] = tmp</span><br><span class="line">                <span class="comment"># 选择下一个待排序元素</span></span><br><span class="line">                k = k + <span class="built_in">h</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="shellsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h, i, j, k, l, tmp;</span><br><span class="line">    <span class="type">int</span> *G = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n/<span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (h = <span class="number">1</span>, i = <span class="number">0</span>; h &lt; n; h = <span class="number">3</span>*h+<span class="number">1</span>) &#123;</span><br><span class="line">        G[i++] = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = i<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        h = G[i];</span><br><span class="line">        <span class="keyword">for</span> (j = h; j &lt; <span class="number">2</span>*h; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = j; k &lt; n; k += h) &#123;</span><br><span class="line">                tmp = A[k];</span><br><span class="line">                l = k;</span><br><span class="line">                <span class="keyword">for</span> (; l-h &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; A[l-h]; l -= h) &#123;</span><br><span class="line">                    A[l] = A[l-h];</span><br><span class="line">                &#125;</span><br><span class="line">                A[l] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="shellsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; G;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">1</span>; h &lt; n; h = <span class="number">3</span>*h+<span class="number">1</span>) &#123;</span><br><span class="line">        G.<span class="built_in">push</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!G.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> h = G.<span class="built_in">top</span>();</span><br><span class="line">        G.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; <span class="number">2</span>*h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = A[j];</span><br><span class="line">                <span class="type">int</span> k = j;</span><br><span class="line">                <span class="keyword">for</span> (; k-h &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; A[k-h]; k -= h) &#123;</span><br><span class="line">                    A[k] = A[k-h];</span><br><span class="line">                &#125;</span><br><span class="line">                A[k] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="树排序"><a href="#树排序" class="headerlink" title="树排序"></a>树排序</h3><p>树排序是将输入数据依次<strong>插入</strong><a href="/DataStructure/Tree#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><strong>二叉搜索树</strong></a>（<code>BST, Binary Search Tree</code>）后，再通过<strong>中序遍历</strong>取回原始数据中以得到有序数据。此方法需要使用辅助存储, 不是原址排序的。</p>
<p>对于输入数据<code>A[n]</code>，排序前预先定义二叉搜索树<code>BST</code>对象，并实现插入<code>insert</code>和中序遍历<code>inorder</code>方法。 步骤如下：</p>
<ol>
<li>遍历<code>A[n]</code>，依次将<code>A[i]</code>插入到<code>BST</code>中以构建树；</li>
<li>中序遍历<code>BST</code>，按照从小到大的顺序依次取回元素到<code>A[n]</code>中；</li>
<li>清空BST，释放自身以及所有节点存储空间。</li>
</ol>
<p>二叉搜索树是否为平衡树，取决于输入数据的插入顺序。最差情况下，树退化为链表。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TreeSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n(balanced)$ $n^2(unbalanced)$</td>
<td align="left">n</td>
<td align="left">yes</td>
<td align="left">插入</td>
<td align="left">使用二叉搜索树时</td>
</tr>
</tbody></table>
<div class="tabs" id="treesort"><ul class="nav-tabs"><li class="tab active"><a href="#treesort-1">Pseudo-R</a></li><li class="tab"><a href="#treesort-2">Pseudo-I</a></li><li class="tab"><a href="#treesort-3">C</a></li><li class="tab"><a href="#treesort-4">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="treesort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BSNode</span><br><span class="line">    e: value of node</span><br><span class="line">    L: left subtree</span><br><span class="line">    <span class="built_in">R</span>: right subtree</span><br><span class="line">BSTree</span><br><span class="line">    root: BSNode，=nul</span><br><span class="line">    <span class="comment"># 插入BST（递归实现）</span></span><br><span class="line">    Insert(x, e)</span><br><span class="line">        <span class="keyword">if</span> x.NotExist</span><br><span class="line">            x = &#123;e,nul,nul&#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> x.e &gt; e</span><br><span class="line">                Insert(x.L, e)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Insert(x.R, e)</span><br><span class="line">    <span class="comment"># 中序遍历（递归实现）</span></span><br><span class="line">    Inorder(x, A)</span><br><span class="line">        <span class="keyword">if</span> x.Exist</span><br><span class="line">            Inorder(x.L, A)</span><br><span class="line">            A &lt;- x.e</span><br><span class="line">            Inorder(x.R, A)</span><br><span class="line">    <span class="comment"># 清空BST（递归实现）</span></span><br><span class="line">    <span class="built_in">Clear</span>(x)</span><br><span class="line">        <span class="keyword">if</span> x.Exist</span><br><span class="line">            <span class="keyword">if</span> x.L.Exist</span><br><span class="line">                <span class="built_in">Clear</span>(x.L)</span><br><span class="line">            <span class="keyword">if</span> x.R.Exist</span><br><span class="line">                <span class="built_in">Clear</span>(x.R)</span><br><span class="line">            delete(x)</span><br><span class="line">TreeSort(A[<span class="type">n</span>])</span><br><span class="line">    T: BSTree</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        T.Insert(T.root, A[<span class="type">i</span>])</span><br><span class="line">    A = T.Inorder(T.root)</span><br><span class="line">    T.Clear(T.root)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="treesort-2"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">BSNode</span><br><span class="line">    e: value of node</span><br><span class="line">    L: left subtree</span><br><span class="line">    <span class="built_in">R</span>: right subtree</span><br><span class="line">BSTree</span><br><span class="line">    root: BSNode，=nul</span><br><span class="line">    <span class="comment"># 插入BST（迭代实现）</span></span><br><span class="line">    Insert(e)</span><br><span class="line">        z: BSNode, =&#123;e,nul,nul&#125;</span><br><span class="line">        y: BSNode, =nul</span><br><span class="line">        x: BSNode, =root</span><br><span class="line">        <span class="comment"># 找到最接近e的叶子节点y</span></span><br><span class="line">        <span class="keyword">while</span> x.Exist</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> x.e &gt; z.e</span><br><span class="line">                x = x.L</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = x.R</span><br><span class="line">        <span class="keyword">if</span> y.NotExist</span><br><span class="line">            <span class="comment"># 将e插入root</span></span><br><span class="line">            root = z</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># 将e插入到y的子树中</span></span><br><span class="line">            <span class="keyword">if</span> y.e &gt; z.e</span><br><span class="line">                y.L = z</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y.R = z</span><br><span class="line">    <span class="comment"># 中序遍历（迭代实现）</span></span><br><span class="line">    Inorder(A)</span><br><span class="line">        S: stack&lt;BSNode&gt;</span><br><span class="line">        x: BSNode, =root</span><br><span class="line">        <span class="comment"># 遍历树中所有的右子树节点（包括根节点）</span></span><br><span class="line">        <span class="keyword">while</span> x.Exist</span><br><span class="line">            <span class="comment"># 自顶向左遍历，依次把右子树和当前节点入栈，直至最左边节点入栈完成</span></span><br><span class="line">            <span class="keyword">while</span> x.Exist</span><br><span class="line">                <span class="keyword">if</span> x.R.Exist</span><br><span class="line">                    S &lt;- x.R</span><br><span class="line">                S &lt;- x</span><br><span class="line">                x = x.L</span><br><span class="line">            <span class="comment"># 从最左边节点开始向顶出栈，直至第一个带右子树的节点出栈完成</span></span><br><span class="line">            x &lt;- S</span><br><span class="line">            <span class="keyword">while</span> S.NotEmpty and x.R.NotExist</span><br><span class="line">                A &lt;- x.e</span><br><span class="line">                x &lt;- S</span><br><span class="line">            A &lt;- x.e</span><br><span class="line">            <span class="comment"># 栈为空，说明自顶向左的入栈的所有节点均没有右子树，即遍历完成</span></span><br><span class="line">            <span class="keyword">if</span> S.Empty</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 将当前节点的右子树节点出栈</span></span><br><span class="line">            x &lt;- S</span><br><span class="line">    <span class="comment"># 清空BST（迭代实现）</span></span><br><span class="line">    <span class="built_in">Clear</span>()</span><br><span class="line">        S: stack&lt;BSNode&gt;</span><br><span class="line">        x: BSNode, =root</span><br><span class="line">        <span class="keyword">while</span> x.Exist</span><br><span class="line">            <span class="keyword">if</span> x.R.Exist</span><br><span class="line">                S &lt;- x.R</span><br><span class="line">            <span class="keyword">if</span> x.L.Exist</span><br><span class="line">                S &lt;- x.L</span><br><span class="line">            delete(x)</span><br><span class="line">            <span class="keyword">if</span> S.Empty</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            x &lt;- S</span><br><span class="line">TreeSort(A[<span class="type">n</span>])</span><br><span class="line">    T: BSTree</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        T.Insert(A[<span class="type">i</span>])</span><br><span class="line">    A = T.Inorder()</span><br><span class="line">    T.Clear()</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="treesort-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> <span class="title">BSNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTree</span> <span class="title">BSTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    BSNode *L;</span><br><span class="line">    BSNode *R;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTree</span> &#123;</span></span><br><span class="line">    BSNode *root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BSTInsert_i</span><span class="params">(BSTree *T, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    BSNode *z = <span class="literal">NULL</span>;</span><br><span class="line">    BSNode *y = <span class="literal">NULL</span>;</span><br><span class="line">    BSNode *x = T-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != x) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;e &gt; e)</span><br><span class="line">            x = x-&gt;L;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;R;</span><br><span class="line">    &#125;</span><br><span class="line">    z = (BSNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSNode));</span><br><span class="line">    z-&gt;e = e;</span><br><span class="line">    z-&gt;L = z-&gt;R = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == y) &#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y-&gt;e &gt; e)</span><br><span class="line">            y-&gt;L = z;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;R = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BSTInsert_r</span><span class="params">(BSNode **x, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == x || <span class="literal">NULL</span> == (*x)) &#123;</span><br><span class="line">        (*x) = (BSNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSNode));</span><br><span class="line">        (*x)-&gt;e = e;</span><br><span class="line">        (*x)-&gt;L = (*x)-&gt;R = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*x)-&gt;e &gt; e)</span><br><span class="line">            BSTInsert_r(&amp;(*x)-&gt;L, e);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            BSTInsert_r(&amp;(*x)-&gt;R, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BSTInorder_r</span><span class="params">(<span class="type">const</span> BSNode *x, <span class="type">int</span> A[], <span class="type">int</span> *i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != x) &#123;</span><br><span class="line">        BSTInorder_r(x-&gt;L, A, i);</span><br><span class="line">        A[(*i)++] = x-&gt;e;</span><br><span class="line">        BSTInorder_r(x-&gt;R, A, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BSTClear_r</span><span class="params">(BSNode *x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != x-&gt;L)</span><br><span class="line">            BSTClear_r(x-&gt;L);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != x-&gt;R)</span><br><span class="line">            BSTClear_r(x-&gt;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&#125;&quot;</span>, x-&gt;e);</span><br><span class="line">        <span class="built_in">free</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TreeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, t = <span class="number">0</span>;</span><br><span class="line">    BSTree *T = (BSTree*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTree));</span><br><span class="line">    T-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                BSTInsert_r(&amp;T-&gt;root, A[i]);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            BSTInorder_r(T-&gt;root, A, &amp;j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                BSTInsert_i(T, A[i]);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            BSTInorder_r(T-&gt;root, A, &amp;j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTClear_r(T-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="treesort-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSNode</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> shared_ptr&lt;BSNode&gt; PBSNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BSNode</span>(<span class="type">int</span> e, PBSNode L = <span class="literal">nullptr</span>, PBSNode R = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">e</span>(e), <span class="built_in">L</span>(L), <span class="built_in">R</span>(R) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span>&amp; <span class="title">getE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span>&amp; <span class="title">getL</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> L; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span>&amp; <span class="title">getR</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> R; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    PBSNode L;</span><br><span class="line">    PBSNode R;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> shared_ptr&lt;BSNode&gt; PBSNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span>&amp; <span class="title">getRoot</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_R</span><span class="params">(PBSNode&amp; x, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            x = <span class="built_in">make_shared</span>&lt;BSNode&gt;(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;<span class="built_in">getE</span>() &gt; e)</span><br><span class="line">                <span class="built_in">insert_R</span>(x-&gt;<span class="built_in">getL</span>(), e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">insert_R</span>(x-&gt;<span class="built_in">getR</span>(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder_R</span><span class="params">(PBSNode x, vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            <span class="built_in">inorder_R</span>(x-&gt;<span class="built_in">getL</span>(), A, i);</span><br><span class="line">            A[i++] = x-&gt;<span class="built_in">getE</span>();</span><br><span class="line">            <span class="built_in">inorder_R</span>(x-&gt;<span class="built_in">getR</span>(), A, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_R</span><span class="params">(PBSNode x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            <span class="built_in">clear_R</span>(x-&gt;<span class="built_in">getL</span>());</span><br><span class="line">            <span class="built_in">clear_R</span>(x-&gt;<span class="built_in">getR</span>());</span><br><span class="line">            x = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_I</span><span class="params">(<span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">        PBSNode z = <span class="built_in">make_shared</span>&lt;BSNode&gt;(e);</span><br><span class="line">        <span class="keyword">decltype</span>(z) y = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">decltype</span>(z) x = root;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;<span class="built_in">getE</span>() &gt; e)</span><br><span class="line">                x = x-&gt;<span class="built_in">getL</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x = x-&gt;<span class="built_in">getR</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!y) &#123;</span><br><span class="line">            root = z;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (y-&gt;<span class="built_in">getE</span>() &gt; e)</span><br><span class="line">                y-&gt;<span class="built_in">getL</span>() = z;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y-&gt;<span class="built_in">getR</span>() = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder_I</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        PBSNode x = root;</span><br><span class="line">        stack&lt;<span class="keyword">decltype</span>(x)&gt; S;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x-&gt;<span class="built_in">getR</span>())</span><br><span class="line">                    S.<span class="built_in">push</span>(x-&gt;<span class="built_in">getR</span>());</span><br><span class="line">                S.<span class="built_in">push</span>(x);</span><br><span class="line">                x = x-&gt;<span class="built_in">getL</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            x = S.<span class="built_in">top</span>();</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span> (!S.<span class="built_in">empty</span>() &amp;&amp; !x-&gt;<span class="built_in">getR</span>()) &#123;</span><br><span class="line">                A[i++] = x-&gt;<span class="built_in">getE</span>();</span><br><span class="line">                x = S.<span class="built_in">top</span>();</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            A[i++] = x-&gt;<span class="built_in">getE</span>();</span><br><span class="line">            <span class="keyword">if</span> (S.<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            x = S.<span class="built_in">top</span>();</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear_I</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PBSNode x = root;</span><br><span class="line">        stack&lt;<span class="keyword">decltype</span>(x)&gt; S;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;<span class="built_in">getR</span>())</span><br><span class="line">                S.<span class="built_in">push</span>(x-&gt;<span class="built_in">getR</span>());</span><br><span class="line">            <span class="keyword">if</span> (x-&gt;<span class="built_in">getL</span>())</span><br><span class="line">                S.<span class="built_in">push</span>(x-&gt;<span class="built_in">getL</span>());</span><br><span class="line">            x = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (S.<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            x = S.<span class="built_in">top</span>();</span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PBSNode root;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    BSTree T;</span><br><span class="line">    <span class="keyword">switch</span>(t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A)</span><br><span class="line">                    T.<span class="built_in">insert_R</span>(T.<span class="built_in">getRoot</span>(), e);</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                T.<span class="built_in">inorder_R</span>(T.<span class="built_in">getRoot</span>(), A, i);</span><br><span class="line">                T.<span class="built_in">clear_R</span>(T.<span class="built_in">getRoot</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A)</span><br><span class="line">                    T.<span class="built_in">insert_I</span>(e);</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                T.<span class="built_in">inorder_I</span>(A);</span><br><span class="line">                T.<span class="built_in">clear_I</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="图书馆排序"><a href="#图书馆排序" class="headerlink" title="图书馆排序"></a>图书馆排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LibrarySort</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$n^2$</td>
<td align="left">n</td>
<td align="left">no</td>
<td align="left">插入</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="librarysort"><ul class="nav-tabs"><li class="tab active"><a href="#librarysort-1">Pseudo</a></li><li class="tab"><a href="#librarysort-2">C</a></li><li class="tab"><a href="#librarysort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="librarysort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibrarySort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="librarysort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LibrarySort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="librarysort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LibrarySort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次遍历数据时，当前元素应放置最小值，因此在剩余的未排序数据中找出最小值，然后与当前元素交换即可。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SelectSort</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">no</td>
<td align="left">选择</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="selectsort"><ul class="nav-tabs"><li class="tab active"><a href="#selectsort-1">Pseudo</a></li><li class="tab"><a href="#selectsort-2">C</a></li><li class="tab"><a href="#selectsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="selectsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SelectSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 从第1个元素开始，遍历到倒数第2个元素（最后一个元素一定有序）</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n<span class="literal">-1</span></span><br><span class="line">        <span class="comment"># 默认当前元素就是最小值</span></span><br><span class="line">        min = i</span><br><span class="line">        <span class="comment"># 从当前元素后一位开始搜索最小值</span></span><br><span class="line">        <span class="keyword">for</span> j = i+<span class="number">1</span> to n</span><br><span class="line">            <span class="keyword">if</span> A[<span class="type">min</span>] &gt; A[<span class="type">j</span>]</span><br><span class="line">                min = j</span><br><span class="line">        <span class="comment"># 将最小值元素与当前元素交换</span></span><br><span class="line">        swap(A[<span class="type">i</span>], A[<span class="type">min</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="selectsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, min, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[min] &gt; A[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = A[i];</span><br><span class="line">        A[i] = A[min];</span><br><span class="line">        A[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="selectsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[min] &gt; A[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="圈排序"><a href="#圈排序" class="headerlink" title="圈排序"></a>圈排序</h3><p>1990年<code>B.K.HADDON</code>在<code>《The Computer Journal》</code>上发表圈排序算法。</p>
<p>对于输入数据<code>A[n]</code>，从左向右依次对每一个元素<code>A[i]</code>进行圈排序，此时<code>p=A[i]</code>即当前圈节点处于起始位置，左侧元素集有序且<code>L&lt;=A[i]</code>，右侧元素集无序且<code>R&gt;=A[i]</code>：</p>
<ol>
<li>在当前元素右侧<code>[i+1,n]</code>中统计小于当前圈节点<code>p</code>的元素数量<code>m</code>，则<code>p</code>的有序位置应为<code>A[i+m]</code>；</li>
<li>如果<code>m=0</code>，说明<code>p</code>的有序位置就是起始位置，即对当前元素圈排序结束，继续对下一个元素<code>A[i+1]</code>进行圈排序；<br>如果<code>m&gt;0</code>，将当前圈节点<code>p</code>放至有序位置<code>A[i+m]</code>，同时更新当前圈节点<code>p=A[i+m]</code>。重复上述步骤直至<code>m=0</code>。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CycleSort</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">no</td>
<td align="left">选择</td>
<td align="left">最优写数量的原址操作</td>
</tr>
</tbody></table>
<div class="tabs" id="cyclesort"><ul class="nav-tabs"><li class="tab active"><a href="#cyclesort-1">Pseudo</a></li><li class="tab"><a href="#cyclesort-2">C</a></li><li class="tab"><a href="#cyclesort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="cyclesort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CycleSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        <span class="comment"># 开始圈排序并计算当前元素的有序位置</span></span><br><span class="line">        p: A[<span class="type">i</span>]</span><br><span class="line">        m: nums of A[<span class="type">i</span>+<span class="number">1</span>,<span class="type">n</span>] &lt; p</span><br><span class="line">        <span class="keyword">if</span> m = <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 更新圈节点直至指向处于起始位置的元素</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt; m</span><br><span class="line">            swap(p, A[<span class="type">i</span>+<span class="type">m</span>])</span><br><span class="line">            m = nums of A[<span class="type">i</span>+<span class="number">1</span>,<span class="type">n</span>] &lt; p</span><br><span class="line">        <span class="comment"># 将当前圈节点放至起始位置</span></span><br><span class="line">        A[<span class="type">i</span>] = p;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="cyclesort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CycleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, p, m, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p = A[i];</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; p)</span><br><span class="line">                m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt; m) &#123;</span><br><span class="line">            tmp = p;</span><br><span class="line">            p = A[i+m];</span><br><span class="line">            A[i+m] = tmp;</span><br><span class="line"></span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; p)</span><br><span class="line">                    m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="cyclesort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CycleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p = A[i];</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; p)</span><br><span class="line">                m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt; m) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(p, A[i+m]);</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &lt; p)</span><br><span class="line">                    m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A[i] = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="链排序"><a href="#链排序" class="headerlink" title="链排序"></a>链排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">StrandSort</td>
<td align="left">n</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">n</td>
<td align="left">yes</td>
<td align="left">选择</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="strandsort"><ul class="nav-tabs"><li class="tab active"><a href="#strandsort-1">Pseudo</a></li><li class="tab"><a href="#strandsort-2">C</a></li><li class="tab"><a href="#strandsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="strandsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrandSort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="strandsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StrandSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="strandsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrandSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>1964年<code>John William</code>发明此算法，提出自顶向下的方法将数组组织为堆，具体为申请新的堆空间后，从一个空堆开始，按顺序向逐渐增长的堆中添加元素。<br>1964年<code>Robert Floyd</code>提出自底向上的方法将数组原地转换为堆，具体为首先构造较小的堆，再将它们合并成很大的堆。<br><strong>堆</strong>是具有以下两个属性的二叉树：</p>
<ol>
<li>每个节点的值不会小于其子节点的值（保证了堆顶元素一定是最大值或最小值）;</li>
<li>树是完全平衡的，最底层的叶子节点都位于最左边的位置上（保证了所有元素在数组中无隙排序）。</li>
</ol>
<p><strong>堆排序</strong>可以看成对<a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><strong>选择排序</strong></a>的改进。堆排序每次将堆顶元素与最后一个元素交换，从尾部开始逐渐构建排序区域，利用<code>Floyd</code>提出的方法原地将以头部开始的未排序区域重新转换为堆，因此相对于选择排序加速了寻找最小值或最大值的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以计数I展示一个长度为N的堆时：                以索引i展示一个长度为N的堆时：</span><br><span class="line">        1                                           0</span><br><span class="line">    2       3                                   1       2</span><br><span class="line">  4   5   6   7                               3   4   5   6</span><br><span class="line"> 8 9                                         7 8</span><br><span class="line"> 左子树节点位置 L = 2I   = 2*2      = 4      左子树节点位置 L = 2i+1 = 2*1+1       = 3</span><br><span class="line"> 右子树节点位置 R = 2I+1 = 2*2+1    = 5      右子树节点位置 R = 2i+2 = 2*1+2       = 4</span><br><span class="line"> 最大子树节点位 P = N/2  = (8or9)/2 = 4      最大子树节点位 P = N/2-1 = (8or9)/2-1 = 3</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HeapSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">1</td>
<td align="left">no</td>
<td align="left">选择</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="heapsort"><ul class="nav-tabs"><li class="tab active"><a href="#heapsort-1">Pseudo</a></li><li class="tab"><a href="#heapsort-2">C</a></li><li class="tab"><a href="#heapsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="heapsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前堆顶元素下坠到正确位置</span></span><br><span class="line"><span class="comment"># start 堆顶元素位置</span></span><br><span class="line"><span class="comment"># end   堆中最后的叶子元素位置</span></span><br><span class="line">Heapify(A, <span class="built_in">start</span>, <span class="keyword">end</span>)</span><br><span class="line">    <span class="comment"># 只要左子树存在，就需要下坠</span></span><br><span class="line">    L = <span class="number">2</span> * <span class="built_in">start</span></span><br><span class="line">    <span class="keyword">while</span> L &lt;= <span class="keyword">end</span></span><br><span class="line">        <span class="comment"># 当右子树存在，获取左右子树中较大的元素</span></span><br><span class="line">        largest = L</span><br><span class="line">        <span class="built_in">R</span> = L + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">R</span> &lt;= <span class="keyword">end</span></span><br><span class="line">            largest = max(A[<span class="type">largest</span>], A[<span class="type">R</span>])</span><br><span class="line">        <span class="comment"># 检查堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> A[<span class="type">start</span>] &lt; A[<span class="type">largest</span>]</span><br><span class="line">            <span class="comment"># 堆顶元素不是最大值，则把它换下去</span></span><br><span class="line">            swap(A[<span class="type">start</span>], A[<span class="type">largest</span>])</span><br><span class="line">            <span class="comment"># 继续处理子树</span></span><br><span class="line">            <span class="built_in">start</span> = largest</span><br><span class="line">            L = <span class="number">2</span> * <span class="built_in">start</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment"># 堆顶元素已经是最大值，直接退出</span></span><br><span class="line">            L = <span class="keyword">end</span> + <span class="number">1</span></span><br><span class="line">HeapSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 构建堆：从最大子节点开始，自底向上依次将各节点的堆顶元素下坠到正确位置</span></span><br><span class="line">    <span class="keyword">for</span> i = n/<span class="number">2</span> to <span class="number">1</span></span><br><span class="line">        Heapify(A, i, n)</span><br><span class="line">    <span class="comment"># 排序：将堆顶元素交换到尾部正确位置，交换上来的元素重新下坠到正确位置</span></span><br><span class="line">    <span class="keyword">for</span> i = n to <span class="number">2</span></span><br><span class="line">        swap(A[<span class="number">1</span>], A[<span class="type">i</span>])</span><br><span class="line">        Heapify(A, <span class="number">1</span>, i<span class="literal">-1</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="heapsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Heapify</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> L, R, largest, tmp;</span><br><span class="line">    L = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= end) &#123;</span><br><span class="line">        largest = L;</span><br><span class="line">        R = L + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= end &amp;&amp; A[largest] &lt; A[R]) &#123;</span><br><span class="line">            largest = R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[start] &lt; A[largest]) &#123;</span><br><span class="line">            tmp = A[start];</span><br><span class="line">            A[start] = A[largest];</span><br><span class="line">            A[largest] = tmp;</span><br><span class="line">            start = largest;</span><br><span class="line">            L = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Heapify(A, i, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp = A[i];</span><br><span class="line">        A[i] = A[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = tmp;</span><br><span class="line">        Heapify(A, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="heapsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> L = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= end) &#123;</span><br><span class="line">        <span class="type">int</span> largest = L;</span><br><span class="line">        <span class="type">int</span> R = L + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (R &lt;= end &amp;&amp; A[largest] &lt; A[R]) &#123;</span><br><span class="line">            largest = R;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[start] &lt; A[largest]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(A[start], A[largest]);</span><br><span class="line">            start = largest;</span><br><span class="line">            L = <span class="number">2</span> * start + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">Heapify</span>(A, i, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(A[<span class="number">0</span>], A[i]);</span><br><span class="line">        <span class="built_in">Heapify</span>(A, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="交换类"><a href="#交换类" class="headerlink" title="交换类"></a>交换类</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>将无序数据集想象为一个垂直的柱体，其中最小的元素在顶部，最大的元素在底部。排序时每次从底部依次比较相邻元素，将较小元素不断上浮，直至上浮至正确位置。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BubbleSort</td>
<td align="left">n</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">yes</td>
<td align="left">交换</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="bubblesort"><ul class="nav-tabs"><li class="tab active"><a href="#bubblesort-1">Pseudo</a></li><li class="tab"><a href="#bubblesort-2">C</a></li><li class="tab"><a href="#bubblesort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="bubblesort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BubbleSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 从第1个元素开始，冒泡到倒数第2个元素（最后一个元素一定有序）</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n<span class="literal">-1</span></span><br><span class="line">        <span class="comment"># 从后向前冒泡，依次交换相邻元素直至最小值冒泡到正确位置</span></span><br><span class="line">        <span class="keyword">for</span> j = n to i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A<span class="function">[<span class="type">j</span>] &lt; <span class="title">A</span></span><span class="function">[<span class="type">j</span>-<span class="number">1</span>]</span></span><br><span class="line">                swap(A[<span class="type">j</span>], A[<span class="type">j</span>-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="bubblesort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                tmp = A[j];</span><br><span class="line">                A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">                A[j<span class="number">-1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="bubblesort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="奇偶排序"><a href="#奇偶排序" class="headerlink" title="奇偶排序"></a>奇偶排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OddEvenSort</td>
<td align="left">n</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">yes</td>
<td align="left">交换</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="oddevensort"><ul class="nav-tabs"><li class="tab active"><a href="#oddevensort-1">Pseudo</a></li><li class="tab"><a href="#oddevensort-2">C</a></li><li class="tab"><a href="#oddevensort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="oddevensort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OddEvenSort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="oddevensort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OddEvenSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="oddevensort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OddEvenSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="摇摆式排序"><a href="#摇摆式排序" class="headerlink" title="摇摆式排序"></a>摇摆式排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CocktailShakerSort</td>
<td align="left">n</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">yes</td>
<td align="left">交换</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="cocktailshakersort"><ul class="nav-tabs"><li class="tab active"><a href="#cocktailshakersort-1">Pseudo</a></li><li class="tab"><a href="#cocktailshakersort-2">C</a></li><li class="tab"><a href="#cocktailshakersort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="cocktailshakersort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CocktailShakerSort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="cocktailshakersort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CocktailShakerSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="cocktailshakersort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CocktailShakerSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="侏儒排序"><a href="#侏儒排序" class="headerlink" title="侏儒排序"></a>侏儒排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GnomeSort</td>
<td align="left">n</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">yes</td>
<td align="left">交换</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="gnomesort"><ul class="nav-tabs"><li class="tab active"><a href="#gnomesort-1">Pseudo</a></li><li class="tab"><a href="#gnomesort-2">C</a></li><li class="tab"><a href="#gnomesort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="gnomesort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GnomeSort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="gnomesort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GnomeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="gnomesort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GnomeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="梳排序"><a href="#梳排序" class="headerlink" title="梳排序"></a>梳排序</h3><p>1980年由<code>Włodzimierz Dobosiewicz</code>和<code>Artur Borowy</code>设计。<br>1991年被<code>Stephen Lacey</code>和<code>Richard Box</code>命名为<code>”CombSort“</code>。<br>梳排序可以看成对<a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><strong>冒泡排序</strong></a>的一种改进。通过步长确定（头&#x2F;尾）数据长度以及对应关系，将各对元素进行交换，使得小值元素在头部，大值元素在尾部。逐渐减小步长以增大尾部范围并重复上述过程，以使得数据愈加有序，最终只需要通过基本排序算法（多为冒泡排序）进行少量的调整即可实现整体有序。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CombSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n^2$</td>
<td align="left">$n^2$</td>
<td align="left">1</td>
<td align="left">no</td>
<td align="left">交换</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="combsort"><ul class="nav-tabs"><li class="tab active"><a href="#combsort-1">Pseudo</a></li><li class="tab"><a href="#combsort-2">C</a></li><li class="tab"><a href="#combsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="combsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CombSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 预处理：先将一些大值元素交换到数组的尾部（步长变化因子1.3为经验值）</span></span><br><span class="line">    step = n</span><br><span class="line">    <span class="keyword">while</span> (step = step/<span class="number">1.3</span>) &gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 按步长选定一对元素进行交换，使得小值元素在头部，大值元素在尾部</span></span><br><span class="line">        <span class="keyword">for</span> i = n to step</span><br><span class="line">            <span class="keyword">if</span> A<span class="function">[<span class="type">i</span>] &lt; <span class="title">A</span></span><span class="function">[<span class="type">i</span>-<span class="type">step</span>]</span></span><br><span class="line">                swap(A[<span class="type">i</span>], A[<span class="type">i</span>-<span class="type">step</span>])</span><br><span class="line">    <span class="comment"># 冒泡排序：只要完成一次冒泡后没有发生交换，就会终止排序</span></span><br><span class="line">    again = true</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> to n<span class="literal">-1</span> and again = true</span><br><span class="line">        again = false</span><br><span class="line">        <span class="keyword">for</span> j = n to i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A<span class="function">[<span class="type">j</span>] &lt; <span class="title">A</span></span><span class="function">[<span class="type">j</span>-<span class="number">1</span>]</span></span><br><span class="line">                swap(A[<span class="type">j</span>], A[<span class="type">j</span>-<span class="number">1</span>])</span><br><span class="line">                again = true</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="combsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CombSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, step = n, tmp, again;</span><br><span class="line">    <span class="keyword">while</span> ((step = (<span class="type">int</span>)(step/<span class="number">1.3</span>)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= step; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i-step]) &#123;</span><br><span class="line">                tmp = A[i];</span><br><span class="line">                A[i] = A[i-step];</span><br><span class="line">                A[i-step] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    again = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span> &amp;&amp; again; i++) &#123;</span><br><span class="line">        again = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                tmp = A[j];</span><br><span class="line">                A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">                A[j<span class="number">-1</span>] = tmp;</span><br><span class="line">                again = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="combsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CombSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> step = n;</span><br><span class="line">    <span class="keyword">while</span> ((step = (<span class="type">int</span>)(step/<span class="number">1.3</span>)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= step; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i-step]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[i-step]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> again = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        again = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j<span class="number">-1</span>]);</span><br><span class="line">                again = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="归并类"><a href="#归并类" class="headerlink" title="归并类"></a>归并类</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>1945年由约翰·冯·诺依曼（<code>John von Neumann</code>）发明。</p>
<p>归并排序的时间复杂度也为$n\log n$，与快速排序比较，在应用数组时较慢，而<strong>应用于链表时较快</strong>，这是因为归并排序会涉及更多移动和更少比较操作。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MergeSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">n</td>
<td align="left">yes</td>
<td align="left">合并</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="mergesort"><ul class="nav-tabs"><li class="tab active"><a href="#mergesort-1">Pseudo</a></li><li class="tab"><a href="#mergesort-2">C</a></li><li class="tab"><a href="#mergesort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="mergesort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并两个有序子列表[p,mid]和[mid+1, r]</span></span><br><span class="line">Merge(A[<span class="type">p</span>,<span class="type">mid</span>], A[<span class="type">mid</span>+<span class="number">1</span>,<span class="type">r</span>], B)</span><br><span class="line">    <span class="comment"># 左侧一半、右侧一半、归并后的数据的起始位置</span></span><br><span class="line">    i = p</span><br><span class="line">    j = mid+<span class="number">1</span></span><br><span class="line">    k = p</span><br><span class="line">    <span class="comment"># 持续比较左右半边的元素，直至较短的一半先归并完成</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid and j &lt;= <span class="built_in">r</span></span><br><span class="line">        <span class="keyword">if</span> A[<span class="type">i</span>] &lt; A[<span class="type">j</span>]</span><br><span class="line">            B[<span class="type">k</span>++] = A[<span class="type">i</span>++]</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            B[<span class="type">k</span>++] = A[<span class="type">j</span>++]</span><br><span class="line">    <span class="comment"># 如果左半边较长，将左边剩余的元素归并完成</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid</span><br><span class="line">        B[<span class="type">k</span>++] = A[<span class="type">i</span>++]</span><br><span class="line">    <span class="comment"># 如果右半边较长，将右边剩余的元素归并完成</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= <span class="built_in">r</span></span><br><span class="line">        B[<span class="type">k</span>++] = A[<span class="type">j</span>++]</span><br><span class="line">    <span class="comment"># 将归并后的数据替换到原始数据中</span></span><br><span class="line">    <span class="keyword">for</span> i = p to <span class="built_in">r</span></span><br><span class="line">        A[<span class="type">i</span>] = B[<span class="type">i</span>]</span><br><span class="line"><span class="comment"># 自顶向下归并（递归实现）</span></span><br><span class="line">MergeSort_t(A[<span class="type">p</span>,<span class="type">r</span>], B)</span><br><span class="line">    <span class="keyword">if</span> p &lt; <span class="built_in">r</span></span><br><span class="line">        <span class="comment"># 计算中间位置</span></span><br><span class="line">        mid = (p+<span class="built_in">r</span>)/<span class="number">2</span></span><br><span class="line">        <span class="comment"># 排序左侧一半</span></span><br><span class="line">        MergeSort_t(A, p, mid, B)</span><br><span class="line">        <span class="comment"># 排序右侧一半</span></span><br><span class="line">        MergeSort_t(A, mid+<span class="number">1</span>, <span class="built_in">r</span>, B)</span><br><span class="line">        <span class="comment"># 将排好序的两半元素合并到一起</span></span><br><span class="line">        Merge(A, p, mid, <span class="built_in">r</span>, B)</span><br><span class="line"><span class="comment"># 自底向上归并（迭代实现）</span></span><br><span class="line">MergeSort_b(A[<span class="type">n</span>], B)</span><br><span class="line">    <span class="comment"># 当子列表宽度为1时，每个元素都是有序的，两个子列表合并后宽度翻倍，直至整个列表有序</span></span><br><span class="line">    <span class="keyword">for</span> width = <span class="number">1</span> to n<span class="literal">-1</span></span><br><span class="line">        <span class="comment"># 将整个列表按宽度切分为各个子列表，然后合并相邻的子列表</span></span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span> to n<span class="literal">-1</span></span><br><span class="line">            <span class="comment"># 计算两个子列表位置后执行合并</span></span><br><span class="line">            p = min(i+width<span class="literal">-1</span>, n)</span><br><span class="line">            <span class="built_in">r</span> = min(i+width*<span class="number">2</span><span class="literal">-1</span>, n)</span><br><span class="line">            Merge(A, i, p, <span class="built_in">r</span>, B)</span><br><span class="line">            <span class="comment"># 跳过已经合并的两个子列表</span></span><br><span class="line">            i = <span class="number">2</span>*width + i</span><br><span class="line">        <span class="comment"># 子列表宽度翻倍</span></span><br><span class="line">        width = <span class="number">2</span>*width</span><br><span class="line">MergeSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 归并排序需要空间存储合并后的数据</span></span><br><span class="line">    B[<span class="type">n</span>]: empty</span><br><span class="line">    <span class="keyword">if</span> useTopDown</span><br><span class="line">        MergeSort_t(A, <span class="number">1</span>, n, B)</span><br><span class="line">    <span class="keyword">if</span> useBottomUp</span><br><span class="line">        MergeSort_b(A, n, B)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="mergesort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> mid, <span class="type">int</span> r, <span class="type">int</span> B[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    i = p;</span><br><span class="line">    j = mid+<span class="number">1</span>;</span><br><span class="line">    k = p;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[j])</span><br><span class="line">            B[k++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            B[k++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        B[k++] = A[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        B[k++] = A[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = p; i &lt;= r; i++)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort_t</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r, <span class="type">int</span> B[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        mid = (p+r)/<span class="number">2</span>;</span><br><span class="line">        MergeSort_t(A, p, mid, B);</span><br><span class="line">        MergeSort_t(A, mid+<span class="number">1</span>, r, B);</span><br><span class="line">        Merge(A, p, mid, r, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort_b</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> B[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> width, i, p, r;</span><br><span class="line">    <span class="keyword">for</span> (width = <span class="number">1</span>; width &lt; n; width *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>*width) &#123;</span><br><span class="line">            p = i+width<span class="number">-1</span>;</span><br><span class="line">            r = i+width*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            p = p &gt; n<span class="number">-1</span> ? n<span class="number">-1</span> : p;</span><br><span class="line">            r = r &gt; n<span class="number">-1</span> ? n<span class="number">-1</span> : r;</span><br><span class="line">            Merge(A, i, p, r, B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: MergeSort_t(A, <span class="number">0</span>, n<span class="number">-1</span>, B); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: MergeSort_b(A, n, B); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="mergesort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> mid, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = p;</span><br><span class="line">    <span class="type">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = p;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[j])</span><br><span class="line">            B[k++] = A[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            B[k++] = A[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        B[k++] = A[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        B[k++] = A[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p; i &lt;= r; i++)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort_t</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (p+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort_t</span>(A, p, mid, B);</span><br><span class="line">        <span class="built_in">MergeSort_t</span>(A, mid+<span class="number">1</span>, r, B);</span><br><span class="line">        <span class="built_in">Merge</span>(A, p, mid, r, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort_b</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> width = <span class="number">1</span>; width &lt; n; width *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += width*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">min</span>(i+width<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">min</span>(i+width*<span class="number">2</span><span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">Merge</span>(A, i, p, r, B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">MergeSort_t</span>(A, <span class="number">0</span>, n<span class="number">-1</span>, B); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">MergeSort_b</span>(A, B); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h3 id="Quad排序"><a href="#Quad排序" class="headerlink" title="Quad排序"></a>Quad排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QuadSort</td>
<td align="left">n</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">n</td>
<td align="left">yes</td>
<td align="left">合并</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="quadsort"><ul class="nav-tabs"><li class="tab active"><a href="#quadsort-1">Pseudo</a></li><li class="tab"><a href="#quadsort-2">C</a></li><li class="tab"><a href="#quadsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="quadsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuadSort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="quadsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuadSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="quadsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuadSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="分治类"><a href="#分治类" class="headerlink" title="分治类"></a>分治类</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>1959年由英国计算机科学家<code>Tony Hoare</code>在<code>Moscow State University</code>作为访问学生时（25岁）开发。采用分治思想，每次从数据中选择一个支点元素<code>pivot</code>，以此为基准将数据分割为两个区域<code>L</code>和<code>R</code>并对剩余元素进行分区，使得<code>pivot</code>元素在分区后处于正确位置，对<code>L</code>和<code>R</code>区域重复上述过程直至所有分区只剩下一个元素时排序完成。</p>
<p>对于输入数据<code>A[n]</code>, 对应区间<code>A[p,r]</code>，<code>Hoare</code>排序步骤如下：</p>
<ol>
<li>选择中间元素（<code>n</code>为偶数时，偏左侧）作为支点元素<code>pivot</code>，将输入数据分割为左区域<code>L</code>和右区域<code>R</code>；</li>
<li>从头向尾寻找<code>&lt;pivot</code>的元素<code>A[i]</code>，从尾向头寻找<code>&gt;pivot</code>的元素<code>A[j]</code>，一旦<code>i&gt;=j</code>时，对<code>A[p,j]</code>和<code>A[j+1,r]</code>重复上述过程。</li>
</ol>
<p>1986年<code>Jon Bentley</code>在<code>“Programming pearls”</code>中推广了<code>Nico Lomuto</code>设计的更简单的<code>Partition</code>实现。</p>
<p>对于输入数据<code>A[n]</code>, 对应区间<code>A[p,r]</code>，<code>Lomuto</code>排序步骤如下：</p>
<ol>
<li>选择最后一个元素作为支点元素<code>pivot</code>，将输入数据分割为左区域<code>L</code>和右区域<code>R</code>；</li>
<li>将<code>A[p,r]</code>中所有小于支点元素<code>pivot</code>的元素依次排列在头部<code>A[p-&gt;i]</code>，然后将<code>pivot</code>元素交换至正确位置应为<code>A[i]</code>；</li>
<li>对左区域<code>L</code>，即<code>A[p-&gt;i-1]</code>和右区域<code>R</code>，即<code>A[i+1,r]</code>重复上述过程。</li>
</ol>
<p>快速排序通常是实践中<strong>最快的比较排序算法</strong>，之所以快，主要由于分组时机恰当且非常高效，其平均时间复杂度为$n\log n$，而且常数因子<code>n</code>往往非常小。但是它的最坏情况为$n^2$，因此与堆排序结合，可以对几乎所有输入都能达到$n\log n$的最坏运行时间。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">QuickSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$n^2$</td>
<td align="left">$\log n$</td>
<td align="left">no</td>
<td align="left">分治</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="quicksort"><ul class="nav-tabs"><li class="tab active"><a href="#quicksort-1">Pseudo-L</a></li><li class="tab"><a href="#quicksort-2">Pseudo-H</a></li><li class="tab"><a href="#quicksort-3">C</a></li><li class="tab"><a href="#quicksort-4">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="quicksort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lomuto分区算法</span></span><br><span class="line">Partition(A[<span class="type">p</span>,<span class="type">r</span>])</span><br><span class="line">    <span class="comment"># 选择最后一个元素作为支点元素</span></span><br><span class="line">    pivot = A[<span class="type">r</span>]</span><br><span class="line">    <span class="comment"># 将所有小于支点元素的元素依次排列在头部</span></span><br><span class="line">    i = p</span><br><span class="line">    <span class="keyword">for</span> j = p to <span class="built_in">r</span></span><br><span class="line">        <span class="keyword">if</span> A[<span class="type">j</span>] &lt; pivot</span><br><span class="line">            swap(A[<span class="type">i</span>], A[<span class="type">j</span>])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将支点元素交换到正确位置</span></span><br><span class="line">    swap(A[<span class="type">i</span>], A[<span class="type">r</span>])</span><br><span class="line">    <span class="comment"># 返回支点元素位置</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"><span class="comment"># Lomuto递归实现</span></span><br><span class="line">QuickSort(A[<span class="type">p</span>,<span class="type">r</span>])</span><br><span class="line">    <span class="keyword">if</span> p &lt; <span class="built_in">r</span></span><br><span class="line">        <span class="comment"># 此算法在分区后pivot元素已经处于正确位置，且左侧均小于pivot，右侧均大于pivot</span></span><br><span class="line">        pivot = Partition(A, p, <span class="built_in">r</span>)</span><br><span class="line">        QuickSort(A, p, pivot<span class="literal">-1</span>)</span><br><span class="line">        QuickSort(A, pivot+<span class="number">1</span>, <span class="built_in">r</span>)</span><br><span class="line"><span class="comment"># Lomuto非递归实现</span></span><br><span class="line">QuickSort(A[<span class="type">p</span>,<span class="type">r</span>])</span><br><span class="line">    S: stack</span><br><span class="line">    S &lt;- p</span><br><span class="line">    S &lt;- <span class="built_in">r</span></span><br><span class="line">    <span class="keyword">while</span> S.NoEmpty </span><br><span class="line">        <span class="built_in">r</span> &lt;- S</span><br><span class="line">        p &lt;- S</span><br><span class="line">        <span class="keyword">if</span> p &lt; <span class="built_in">r</span></span><br><span class="line">            pivot = Partition(A, p, <span class="built_in">r</span>)</span><br><span class="line">            <span class="keyword">if</span> pivot &gt; p + <span class="number">1</span></span><br><span class="line">                S &lt;- p</span><br><span class="line">                S &lt;- pivot<span class="literal">-1</span></span><br><span class="line">            <span class="keyword">if</span> pivot &lt; <span class="built_in">r</span> - <span class="number">1</span></span><br><span class="line">                S &lt;- pivot+<span class="number">1</span></span><br><span class="line">                S &lt;- <span class="built_in">r</span></span><br><span class="line">QuickSort(A[<span class="type">n</span>])</span><br><span class="line">    QuickSort(A, <span class="number">1</span>, n)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="quicksort-2"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hoare分区算法</span></span><br><span class="line">Partition(A[<span class="type">p</span>,<span class="type">r</span>])</span><br><span class="line">    <span class="comment"># 选择支点元素，floor舍弃余数使得:</span></span><br><span class="line">    <span class="comment"># 当元素个数为奇数时，支点元素即中间元素；</span></span><br><span class="line">    <span class="comment"># 当元素个数为偶数时，支点元素偏左侧些。</span></span><br><span class="line">    <span class="comment"># 例如A=&#123;3,4&#125;时，pivot为3；A=&#123;4,3&#125;时，pivot为4。</span></span><br><span class="line">    pivot = A[<span class="type">floor</span>((<span class="type">p</span>+<span class="type">r</span>)/<span class="number">2</span>)]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    j = <span class="built_in">r</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> true</span><br><span class="line">        <span class="comment"># 从左向右寻找下一个不小于支点元素的元素</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> A[<span class="type">i</span>] &lt; pivot</span><br><span class="line">        <span class="comment"># 从右向左寻找下一个不大于支点元素的元素</span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> A[<span class="type">j</span>] &gt; pivot</span><br><span class="line">        <span class="comment"># 一旦左右寻找范围交叉即停止</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j</span><br><span class="line">            <span class="comment"># 此时pivot元素位置无法确定，可能在A[i]、A[j]或者其他位置；</span></span><br><span class="line">            <span class="comment"># 元素被划分了两半，一半不大于pivot，另一半相反，分割位置只能用j的右侧表示（i的左侧不能表示）；</span></span><br><span class="line">            <span class="comment"># 例如A=&#123;3,4&#125;时，A[i]=A[j]=3；A=&#123;4,3&#125;时，A[i]=4而A[j]=3。</span></span><br><span class="line">            <span class="comment"># （由于pivot偏左侧，因此无论A=&#123;3,4&#125;还是A=&#123;4,3&#125;，都不可能出现A[i]=A[j]=4的情况）</span></span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        <span class="comment"># 交换寻找到的元素，使得小元素在左侧，大元素在右侧</span></span><br><span class="line">        swap(A[<span class="type">i</span>], A[<span class="type">j</span>])</span><br><span class="line"><span class="comment"># Hoare递归实现</span></span><br><span class="line">QuickSort(A[<span class="type">p</span>,<span class="type">r</span>])</span><br><span class="line">    <span class="keyword">if</span> p &lt; <span class="built_in">r</span></span><br><span class="line">        <span class="comment"># 此算法在分区后只能区分两半元素的分割位置，pivot元素不一定处于正确位置</span></span><br><span class="line">        pivot = Partition(A, p, <span class="built_in">r</span>)</span><br><span class="line">        QuickSort(A, p, pivot)</span><br><span class="line">        QuickSort(A, pivot+<span class="number">1</span>, <span class="built_in">r</span>)</span><br><span class="line"><span class="comment"># Hoare非递归实现</span></span><br><span class="line">QuickSort(A[<span class="type">p</span>,<span class="type">r</span>])</span><br><span class="line">    S: stack</span><br><span class="line">    S &lt;- p</span><br><span class="line">    S &lt;- <span class="built_in">r</span></span><br><span class="line">    <span class="keyword">while</span> S.NoEmpty </span><br><span class="line">        <span class="built_in">r</span> &lt;- S</span><br><span class="line">        p &lt;- S</span><br><span class="line">        <span class="keyword">if</span> p &lt; <span class="built_in">r</span></span><br><span class="line">            pivot = Partition(A, p, <span class="built_in">r</span>)</span><br><span class="line">            <span class="keyword">if</span> pivot &gt; p + <span class="number">1</span></span><br><span class="line">                S &lt;- p</span><br><span class="line">                S &lt;- pivot</span><br><span class="line">            <span class="keyword">if</span> pivot &lt; <span class="built_in">r</span> - <span class="number">1</span></span><br><span class="line">                S &lt;- pivot+<span class="number">1</span></span><br><span class="line">                S &lt;- <span class="built_in">r</span></span><br><span class="line">QuickSort(A[<span class="type">n</span>])</span><br><span class="line">    QuickSort(A, <span class="number">1</span>, n)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="quicksort-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition_l</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot, i, j, tmp;</span><br><span class="line">    pivot = A[r];</span><br><span class="line">    i = p;</span><br><span class="line">    <span class="keyword">for</span> (j = p; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] &lt; pivot) &#123;</span><br><span class="line">            tmp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = tmp;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = A[i];</span><br><span class="line">    A[i] = A[r];</span><br><span class="line">    A[r] = tmp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort_lr</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        pivot = Partition_l(A, p, r);</span><br><span class="line">        QuickSort_lr(A, p, pivot<span class="number">-1</span>);</span><br><span class="line">        QuickSort_lr(A, pivot+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition_h</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> q, pivot, i, j, tmp;</span><br><span class="line">    q = (<span class="type">int</span>)<span class="built_in">floor</span>((p+r)/<span class="number">2</span>);</span><br><span class="line">    pivot = A[q];</span><br><span class="line">    i = p - <span class="number">1</span>;</span><br><span class="line">    j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        tmp = A[i];</span><br><span class="line">        A[i] = A[j];</span><br><span class="line">        A[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort_hr</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        pivot = Partition_h(A, p, r);</span><br><span class="line">        QuickSort_hr(A, p, pivot);</span><br><span class="line">        QuickSort_hr(A, pivot+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == t) &#123;</span><br><span class="line">        QuickSort_lr(A, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QuickSort_hr(A, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="quicksort-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition_l</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[r];</span><br><span class="line">    <span class="type">int</span> i = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = p; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(A[i], A[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort_lr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition_l</span>(A, p, r);</span><br><span class="line">        <span class="built_in">QuickSort_lr</span>(A, p, pivot<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort_lr</span>(A, pivot+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort_ls</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    S.<span class="built_in">push</span>(p);</span><br><span class="line">    S.<span class="built_in">push</span>(r);</span><br><span class="line">    <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        r = S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        p = S.<span class="built_in">top</span>();</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = <span class="built_in">Partition_l</span>(A, p, r);</span><br><span class="line">            <span class="keyword">if</span> (pivot<span class="number">-1</span> &gt; p) &#123;</span><br><span class="line">                <span class="built_in">QuickSort_ls</span>(A, p, pivot<span class="number">-1</span>);</span><br><span class="line">                S.<span class="built_in">push</span>(p);</span><br><span class="line">                S.<span class="built_in">push</span>(pivot<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pivot+<span class="number">1</span> &lt; r) &#123;</span><br><span class="line">                <span class="built_in">QuickSort_ls</span>(A, pivot+<span class="number">1</span>, r);</span><br><span class="line">                S.<span class="built_in">push</span>(pivot+<span class="number">1</span>);</span><br><span class="line">                S.<span class="built_in">push</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition_h</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = (<span class="type">int</span>)<span class="built_in">floor</span>((p+r)/<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> pivot = A[q];</span><br><span class="line">    <span class="type">int</span> i = p - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">while</span> (A[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort_hr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> p, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">Partition_h</span>(A, p, r);</span><br><span class="line">        <span class="built_in">QuickSort_hr</span>(A, p, pivot);</span><br><span class="line">        <span class="built_in">QuickSort_hr</span>(A, pivot+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">QuickSort_lr</span>(A, <span class="number">0</span>, n<span class="number">-1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">QuickSort_ls</span>(A, <span class="number">0</span>, n<span class="number">-1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">QuickSort_hr</span>(A, <span class="number">0</span>, n<span class="number">-1</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="混合类"><a href="#混合类" class="headerlink" title="混合类"></a>混合类</h2><h3 id="内省排序"><a href="#内省排序" class="headerlink" title="内省排序"></a>内省排序</h3><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">Method</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IntroSort</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$n\log n$</td>
<td align="left">$\log n$</td>
<td align="left">no</td>
<td align="left">分治与选择</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="introsort"><ul class="nav-tabs"><li class="tab active"><a href="#introsort-1">Pseudo</a></li><li class="tab"><a href="#introsort-2">C</a></li><li class="tab"><a href="#introsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="introsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntroSort(A[<span class="type">n</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="introsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntroSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="introsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IntroSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="非比较类"><a href="#非比较类" class="headerlink" title="非比较类"></a>非比较类</h1><p>比较类算法的最坏时间复杂度至少为$nlogn$，而非比较类算法不受此限制。</p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>1954年<code>Harold H. Seward</code>发明了计数排序并应用到基数排序中。<br>计数排序是<strong>一种正整数排序算法</strong>，它是<strong>稳定</strong>的，常被用作<a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><strong>基数排序</strong></a>算法的一个子过程。</p>
<p>计数排序假设输入数据<code>A[n]</code>中的元素都是在<code>[0,k]</code>区间内的一个正整数：</p>
<ol>
<li>在输入数据<code>A[n]</code>中查找最大元素<code>k</code>，并创建计数存储数组<code>C[k]</code>，各元素初始计数为<code>0</code>；</li>
<li>统计输入数据<code>A[n]</code>中各元素出现的次数，结果保存到<code>C[k]</code>；</li>
<li>将出现次数累加，使<code>C[e]</code>中值为小于或等于<code>e</code>元素的个数，即<code>C[e]</code>为最后出现的<code>e</code>元素的有序位置；</li>
<li>根据<code>C[k]</code>中的计数，从<code>A[n]</code>尾部开始遍历，得到有序的数据<code>B[n]</code>。</li>
</ol>
<p>当<code>k</code>值越小、<code>n</code>越大时，计数排序的性能越好。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">$n&lt;&lt;2^k$</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CountingSort</td>
<td align="left">-</td>
<td align="left">n+r</td>
<td align="left">n+r</td>
<td align="left">n+r</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="countingsort"><ul class="nav-tabs"><li class="tab active"><a href="#countingsort-1">Pseudo</a></li><li class="tab"><a href="#countingsort-2">C</a></li><li class="tab"><a href="#countingsort-3">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="countingsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CountingSort(A[<span class="type">n</span>])</span><br><span class="line">    <span class="comment"># 统计各元素小于或等于其自身的元素的个数</span></span><br><span class="line">    k: max(A[<span class="number">1</span>], A[<span class="number">2</span>], ... A[<span class="type">n</span>])</span><br><span class="line">    C[<span class="type">k</span>]: array[<span class="type">value</span>=<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        C[<span class="type">A</span>[<span class="type">i</span>]]++</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span> to n</span><br><span class="line">        C[<span class="type">i</span>] += C[<span class="type">i</span>-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 从尾到头遍历A，根据统计的计数得到有序数据B</span></span><br><span class="line">    B[<span class="type">n</span>]: array</span><br><span class="line">    <span class="keyword">for</span> i = n to <span class="number">1</span></span><br><span class="line">        B[<span class="type">C</span>[<span class="type">A</span>[<span class="type">i</span>]]] = A[<span class="type">i</span>]</span><br><span class="line">        C[<span class="type">A</span>[<span class="type">i</span>]]<span class="literal">--</span></span><br><span class="line">    <span class="comment"># 将有序数据B更新回原始数据A</span></span><br><span class="line">    A[<span class="type">n</span>] = B[<span class="type">n</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="countingsort-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountingSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *B;</span><br><span class="line">    <span class="type">unsigned</span> *C;</span><br><span class="line">    <span class="type">int</span> i, k;</span><br><span class="line">    k = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; A[i])</span><br><span class="line">            k = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    C = (<span class="type">unsigned</span>*)<span class="built_in">malloc</span>((k+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">unsigned</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        C[i] += C[i<span class="number">-1</span>];</span><br><span class="line">    B = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        B[C[A[i]]<span class="number">-1</span>] = A[i];</span><br><span class="line">        C[A[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="countingsort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> k = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A)</span><br><span class="line">        k = <span class="built_in">max</span>(k, e);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">C</span><span class="params">(k+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A)</span><br><span class="line">        C[e]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        C[i] += C[i<span class="number">-1</span>];</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        B[C[A[i]]<span class="number">-1</span>] = A[i]; </span><br><span class="line">        C[A[i]]--;           </span><br><span class="line">    &#125;                        </span><br><span class="line">    A = B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序起源于<a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><strong>计数排序</strong></a>，计数排序分离原始数据中的每个元素，然后再放回正确的位置，桶排序也做同样的事情，将元素放到桶中过程实质上执行了一个<code>K</code>路比较，这比简单比较类算法更为强大。<strong>当每桶中的元素数量为1时，桶排序退化为计数排序。</strong></p>
<p>桶排序要求输入数据出现的概率<strong>均匀分布</strong>在<code>[0,1)</code>区间上：</p>
<ol>
<li>将此区间划分为<code>k</code>个大小相等的子区间（也称为桶），使得各桶之间是有序的。</li>
<li>遍历输入数据分别放到各个桶中，然后对每个桶中的元素进行排序。</li>
<li>遍历每个桶，依次将桶中元素取回原始数据中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0k --- 1k --- 2k --- n   A:原始数据</span><br><span class="line">B1     B2     B3         B:桶</span><br><span class="line">当A[n]占用区间范围为[0,25)、 k=5时， B1[0..4] B2[5..9]   ... B5[20..24]</span><br><span class="line">当A[n]占用区间范围为[0,100)、k=10时，B1[0..9] B2[10..19] ... B10[90..99]</span><br></pre></td></tr></table></figure>

<p>对于输入数据<code>A[n]</code>，元素<code>A[i]</code>占用的区间范围为<code>[p,r+1)</code>，当桶数量为<code>k</code>时：</p>
<ul>
<li>每桶中的元素数量<code>m=ceil((double)(r-p+1)/k)</code>；</li>
<li>每个元素<code>A[i]</code>对应的桶<code>B[j]</code>：<code>j=floor((A[i]-p)/m)</code>;</li>
</ul>
<p>当<code>p,r</code>值越小、<code>n</code>越大时，相对比较类排序算法，桶排序的优势越明显。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">$n&lt;&lt;2^k$</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BucketSort</td>
<td align="left">-</td>
<td align="left">n+k</td>
<td align="left">n+k</td>
<td align="left">n+k</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="bucketsort"><ul class="nav-tabs"><li class="tab active"><a href="#bucketsort-1">Pseudo</a></li><li class="tab"><a href="#bucketsort-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="bucketsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BucketSort(A[<span class="type">n</span>], k)</span><br><span class="line">    p: min(A[<span class="number">1</span>], A[<span class="number">2</span>], ... A[<span class="type">n</span>])</span><br><span class="line">    <span class="built_in">r</span>: max(A[<span class="number">1</span>], A[<span class="number">2</span>], ... A[<span class="type">n</span>])</span><br><span class="line">    m: ceil((double)(<span class="built_in">r</span><span class="literal">-p</span>+<span class="number">1</span>)/k)</span><br><span class="line">    B[<span class="type">k</span>]: array[<span class="type">empty</span> <span class="type">list</span>]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">        j = floor((A[<span class="type">i</span>]<span class="literal">-p</span>)/m)</span><br><span class="line">        B[<span class="type">j</span>] &lt;- A[<span class="type">i</span>]</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> to k</span><br><span class="line">        <span class="comment"># 也可以使用冒泡排序等</span></span><br><span class="line">        InsertSort(B[<span class="type">i</span>])</span><br><span class="line">    A = Concat(B[<span class="number">1</span>], B[<span class="number">2</span>], ... B[<span class="type">k</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="bucketsort-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort_k</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();          </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)                 </span><br><span class="line">        <span class="keyword">return</span>;                </span><br><span class="line">    <span class="type">int</span> p = A[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> r = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; e)</span><br><span class="line">            p = e;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; e)</span><br><span class="line">            r = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">ceil</span>((<span class="type">double</span>)(r-p+<span class="number">1</span>)/k);</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">B</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A) &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">floor</span>((e-p)/m);</span><br><span class="line">        <span class="keyword">auto</span>&amp; L =  B[j];</span><br><span class="line">        L.<span class="built_in">push_back</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; L : B) &#123;</span><br><span class="line">        L.<span class="built_in">sort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; L : B) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : L) &#123;</span><br><span class="line">            A[i++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BucketSort_k</span>(A, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>1887年<code>Herman Hollerith</code>研究制表机发明此算法。1923年作为一种对穿孔卡片进行排序的方法普遍使用。<br>基数排序常应用于字符串和整数数据，数据中的每一个元素，都可以看成由一定长度的位组合而成，从左向右按位遍历元素时称为按最高有效位（<code>MSD, Most significant digit</code>）遍历，反之称为按最低有效位（<code>LSD, Least significant digit</code>）遍历，每一次遍历时需使用一种稳定排序算法（常使用<a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><strong>桶排序</strong></a>或<a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><strong>计数排序</strong></a>）按当前位对所有数据进行排序，待遍历完所有位后即获得有序数据。</p>
<p>对于输入数据<code>A[n]</code>，每一个元素都可以由<code>d</code>位构成，按最低有效位（<code>LSD</code>）基于桶排序进行基数排序时：</p>
<ol>
<li>按位分析输入数据，使得元素的每一位的值都唯一对应到桶，从而确定桶数量<code>k</code>;</li>
<li>从第<code>d</code>位依次遍历至第<code>1</code>位，每次遍历时都按照当前位的值将各元素放到桶中，完毕后再将各桶中元素取回值原始数据中；</li>
<li>由于进行第<code>i</code>位桶排序时，各元素已经是按照第<code>i+1</code>位排序的，当<code>i</code>减少为<code>1</code>时，最后一次桶排序后原始数据即为有序的。</li>
</ol>
<p>基数排序对<strong>整数排序</strong>非常快，通常快于更通用的比较类排序算法。</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Best</th>
<th align="left">Average</th>
<th align="left">Worst</th>
<th align="left">Memory</th>
<th align="left">Stable</th>
<th align="left">$n&lt;&lt;2^k$</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LSDRadixSort</td>
<td align="left">n</td>
<td align="left">$n·{k \over d}$</td>
<td align="left">$n·{k \over d}$</td>
<td align="left">$n+2^d$</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">MSDRadixSort</td>
<td align="left">-</td>
<td align="left">$n·{k \over d}$</td>
<td align="left">$n·{k \over d}$</td>
<td align="left">$n+2^d$</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left"></td>
</tr>
</tbody></table>
<div class="tabs" id="radixsort"><ul class="nav-tabs"><li class="tab active"><a href="#radixsort-1">Pseudo</a></li><li class="tab"><a href="#radixsort-2">C++</a></li></ul><div class="tab-content"><div class="tab-pane active" id="radixsort-1"><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RadixSort(A[<span class="type">n</span>], d)</span><br><span class="line">    <span class="comment"># 确定桶数量</span></span><br><span class="line">    k: <span class="number">10</span>/integer or <span class="number">256</span>/ascii or <span class="number">2</span>/binary</span><br><span class="line">    B[<span class="type">k</span>]: array[<span class="type">empty</span> <span class="type">list</span>]</span><br><span class="line">    <span class="comment"># 按LSD进行基数排序</span></span><br><span class="line">    <span class="keyword">for</span> i = d to <span class="number">1</span></span><br><span class="line">        <span class="comment"># 元素按位放到各桶中</span></span><br><span class="line">        <span class="keyword">for</span> j = <span class="number">1</span> to n</span><br><span class="line">            B[<span class="type">A</span>[<span class="type">j</span>][<span class="type">i</span>]] &lt;- A[<span class="type">j</span>]</span><br><span class="line">        <span class="comment"># 各桶中元素取回至原始数据</span></span><br><span class="line">        A = Concat(B[<span class="number">1</span>], B[<span class="number">2</span>], ... B[<span class="type">k</span>])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="radixsort-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort_b</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> k = <span class="number">10</span>;</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">B</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = d<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : A) &#123;</span><br><span class="line">            <span class="type">int</span> pos = e/(<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, d-i<span class="number">-1</span>)%<span class="number">10</span>;</span><br><span class="line">            B[pos].<span class="built_in">push_back</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; L : B) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : L)</span><br><span class="line">                A[idx++] = e;</span><br><span class="line">            L.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RadixSort_b</span>(A, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><ul>
<li><code>qsort</code> 不保证稳定性，使用<a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><strong>快速排序</strong></a>。</li>
</ul>
<div class="tabs" id="c_sort"><ul class="nav-tabs"><li class="tab active"><a href="#c_sort-1">qsort</a></li></ul><div class="tab-content"><div class="tab-pane active" id="c_sort-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QCompare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    n1 = *(<span class="type">int</span>*)p1;</span><br><span class="line">    n2 = *(<span class="type">int</span>*)p2;</span><br><span class="line">    <span class="keyword">return</span> n1 &gt; n2; <span class="comment">// 从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QSortDemo</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    qsort(A, n, <span class="keyword">sizeof</span>(<span class="type">int</span>), QCompare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ (STL)"></a>C++ (STL)</h1><ul>
<li><code>sort</code><br>不保证算法稳定性，在<code>HP</code>和<code>Microsoft</code>的实现中使用<a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><strong>快速排序</strong></a>算法。当快排时每次分区选择的支点元素有序位置总是严重偏向一侧时，分区次数增加，时间复杂度越趋近最坏情况$n^2$，此时会切换为<a href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><strong>堆排序</strong></a>算法，以将最坏情况下的时间复杂度降低至$n\log n$。</li>
<li><code>stable_sort</code><br>保证算法稳定性，在<code>HP</code>和<code>Microsoft</code>的实现中使用混合<a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><strong>归并排序</strong></a>算法。使用<a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><strong>插入排序</strong></a>算法创建由32个元素组成的有序组，然后利用<strong>自底向上的归并排序</strong>算法对有序组进行合并。</li>
<li><code>partial_sort</code><br>在<code>[p,r]</code>的元素范围内，只将前面的元素<code>[p,q&lt;=r)</code>中的元素排列为有序状态（有序是相对<code>[p,r]</code>中的所有元素的）。</li>
<li><code>partial_sort_copy</code><br>在<code>A[p1,r1]</code>和<code>B[p2,r2]</code>中同时搜索，寻找前<code>r2-p2+1</code>个元素放到<code>B</code>中。</li>
<li><code>partition</code><br>将<code>A[p,r]</code>按一定条件分割为两半<code>L[p,q)</code>和<code>R[q,r]</code>（类似快排的<code>Hoare</code>分区算法）。</li>
<li><code>make_heap/sort_heap</code><br><code>c++20</code>新增，分别对应<a href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><strong>堆排序</strong></a>的两个步骤，<code>make_heap</code>将容器构造为堆，<code>sort_heap</code>将堆转换为有序数据。</li>
</ul>
<div class="tabs" id="c++_sort"><ul class="nav-tabs"><li class="tab active"><a href="#c++_sort-1">sort</a></li><li class="tab"><a href="#c++_sort-2">stable_sort</a></li><li class="tab"><a href="#c++_sort-3">partial_sort</a></li><li class="tab"><a href="#c++_sort-4">partial_sort_copy</a></li><li class="tab"><a href="#c++_sort-5">partition</a></li><li class="tab"><a href="#c++_sort-6">heap_sort</a></li></ul><div class="tab-content"><div class="tab-pane active" id="c++_sort-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SortDemo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从小到大</span></span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">    <span class="comment">// 从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="c++_sort-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StableSortDemo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 从小到大</span></span><br><span class="line">    <span class="built_in">stable_sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">stable_sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line">    <span class="comment">// 从大到小</span></span><br><span class="line">    <span class="built_in">stable_sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="c++_sort-3"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartialSortDemo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 所有元素中找到前3个最小元素</span></span><br><span class="line">    <span class="built_in">partial_sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">begin</span>()+<span class="number">3</span>, A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 所有元素中找到前3个最大元素</span></span><br><span class="line">    <span class="built_in">partial_sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">begin</span>()+<span class="number">3</span>, A.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="c++_sort-4"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartialSortCopyDemo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 在A和B组成的元素中找到前B.size个最小元素</span></span><br><span class="line">    <span class="built_in">partial_sort_copy</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 在A和B组成的元素中找到前B.size个最大元素</span></span><br><span class="line">    <span class="built_in">partial_sort_copy</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), B.<span class="built_in">begin</span>(), B.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="c++_sort-5"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionDemo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 将A中元素分区，使得L半边为偶数，R半边为奇数</span></span><br><span class="line">    <span class="built_in">partition</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;);</span><br><span class="line">    <span class="built_in">is_partitioned</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort_lr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;::iterator p, vector&lt;<span class="type">int</span>&gt;::iterator r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 选择最后一个元素作为支点元素pivot</span></span><br><span class="line">        <span class="keyword">auto</span> pivot = <span class="built_in">prev</span>(r);</span><br><span class="line">        <span class="comment">// 根据pivot元素分区为[p,q)和[q,r)（pivot元素不参与分区过程）</span></span><br><span class="line">        <span class="keyword">auto</span> q = <span class="built_in">partition</span>(p, pivot, [pivot](<span class="type">int</span>&amp; x) &#123; <span class="keyword">return</span> x &lt; *pivot; &#125;);</span><br><span class="line">        <span class="comment">// 将pivot元素交换至正确位置</span></span><br><span class="line">        <span class="built_in">iter_swap</span>(pivot, q);</span><br><span class="line">        <span class="comment">// 递归分区[p,pivot)和[pivot+1, r)</span></span><br><span class="line">        <span class="built_in">QuickSort_lr2</span>(p, pivot);</span><br><span class="line">        <span class="built_in">QuickSort_lr2</span>(pivot+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort_hr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;::iterator p, vector&lt;<span class="type">int</span>&gt;::iterator r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 选择中间元素作为支点元素pivot（偶数时偏左）</span></span><br><span class="line">        <span class="keyword">auto</span> pivot = *<span class="built_in">next</span>(p, <span class="built_in">distance</span>(p,r)/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 分区为[p,mid1)都是小于pivot的元素和[mid1,r)</span></span><br><span class="line">        <span class="keyword">auto</span> mid1 = <span class="built_in">partition</span>(p, r, [pivot](<span class="type">int</span>&amp; x) &#123; <span class="keyword">return</span> x &lt; pivot; &#125;);</span><br><span class="line">        <span class="comment">// 再分区一次，确保[mid2,r)都是大于Pivot的元素</span></span><br><span class="line">        <span class="keyword">auto</span> mid2 = <span class="built_in">partition</span>(mid1, r, [pivot](<span class="type">int</span>&amp; x) &#123; <span class="keyword">return</span> x &lt;= pivot; &#125;);</span><br><span class="line">        <span class="built_in">QuickSort_hr2</span>(p, mid1);</span><br><span class="line">        <span class="built_in">QuickSort_hr2</span>(mid2, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">QuickSort_lr</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">QuickSort_hr</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="c++_sort-6"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSortDemo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建大顶堆</span></span><br><span class="line">    <span class="built_in">make_heap</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 将大顶堆转换为从小到大的数据</span></span><br><span class="line">    <span class="built_in">sort_heap</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Data Structures and Algorithms in C++, 4th Edition (Adam Drozdek)<br>[2] <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a><br>[3] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sorting_algorithm">https://en.wikipedia.org/wiki/Sorting_algorithm</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Sort/" rel="tag"><i class="fa fa-tag"></i> Sort</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Hexo/Sample.html" rel="prev" title="Hexo示例">
                  <i class="fa fa-chevron-left"></i> Hexo示例
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/DataStructure/BinarySearchTree/BinarySearchTree.html" rel="next" title="二叉搜索树">
                  二叉搜索树 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-burn"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ssyang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Symbols count total">413k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:16</span>
  </span>
</div>
  <div class="powered-by"><a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a>/<a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT</a>
  </div>

    </div>
  </footer>

  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="/lib/jquery/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="/lib/@fancyapps/fancybox/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="/lib/pangu/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="/lib/hexo-generator-searchdb/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"/lib/pdfobject/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"/lib/mermaid/dist/mermaid.min.js","integrity":"sha256-CmZCFVnvol9YL23PfjDflGY5nJwE+Mf/JN+8v+tD/34="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"/lib/mathjax/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="/lib/quicklink/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://blog.imssyang.com/Algorithm/Sort.html"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<link rel="stylesheet" href="/lib/disqusjs/dist/disqusjs.css" integrity="sha256-GxdCIOyfxQ1OBfS99qAIJDoGK1ADuBsxhMTqXG82fAY=" crossorigin="anonymous">

<script class="next-config" data-name="disqusjs" type="application/json">{"enable":true,"api":"https://disqus.com/api/","apikey":"9zaN2jW6zXMHxC3NctLnrVsVuNe4yZ8CyZ1rWAJQKcIc7JMaHNPP9m4vra2AJeIA","shortname":"imssyang","js":{"url":"/lib/disqusjs/dist/disqus.js","integrity":"sha256-LVaMHPQ2zLqOc5rXSAfr4d1PIkEGNLyyUTDNPZmTtUw="}}</script>
<script src="/js/third-party/comments/disqusjs.js"></script>

</body>
</html>
